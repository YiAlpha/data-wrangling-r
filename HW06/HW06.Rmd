---
title: "HW06：Working with Strings"
author: "YI YIN"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.path="images/",
                      cache.path="cache/",
                      cache=TRUE,
                      message=FALSE,
                      warning=FALSE)

```


# 1. Words in Ulysses

```{r Ulysses, include=FALSE}
## Please don't show this code or output in your homework

# Install and load the package `gutenbergr`. 
# install.packages("gutenbergr")
library(gutenbergr)
# Let's get the book "Ulysses" by James Joyce
gutenberg_works(author == "Joyce, James")
book <- gutenberg_download(4300)
book

# Install and load the package `tidytext`. 
# install.packages('tidytext')
library(tidytext)
library(tidyverse)
# Now let's get the words in the text
words <- book %>%
  unnest_tokens(word, text) %>%
  select(word)
words

```


## a) Words with z
Select all unique words that contain at least one z.

```{r}
z_words <- words$word%>%str_subset("z")%>%unique()
```

Among the z-words, tabulate how many z’s the words contain (i.e. how many words contain one z, two z’s etc.). 

```{r}
z_words%>%str_count("z")%>%table()
```

Find the z-word(s) with z’s that are as far apart as possible (i.e. we are interested in the distance between two z’s in the word. That means the word could contain more than two z’s.).

```{r}
z_2more <- z_words%>%
        str_split("z", simplify = TRUE) %>% 
        as_tibble() %>% 
        cbind(z_words)%>%
        rename(full_word = z_words)%>%
        filter(V3!="")%>%
        mutate(z1_z2 = nchar(V2))%>%
        mutate(z2_z3 = ifelse(V4 =="", NA, nchar(V3)))%>%
        mutate(z1_z3 =  ifelse(V4 =="", NA,
                               nchar(V2)+nchar(V3)))

# Max distance between first z and second z
z_2more%>%top_n(1, z1_z2)

# Max distance between second z and third z
z_2more%>%top_n(1, z2_z3)

# Max distance between first z and third z
z_2more%>%top_n(1, z1_z3)


```

**Therefore, `százharminczbrojúgulyás` is the word with largest distance between "z"s.**

b) Vowels
How many unique words start and end with a vowel? 

**-- 876 words start and end with a vowel?**
```{r}
v_words <- words$word%>%str_subset("^[aeiou].*[aeiou]$")%>%unique()
length(v_words)

```

Are there words that start with two or more vowels? 

**-- 72 words start with two or more vowels and end with a vowel.**
```{r}
words$word%>%str_subset("^[aeiou]{2,}")%>%unique()%>%length()
```

**-- 341 words start with two or more vowels.**
```{r}
v_words%>%str_subset("^[aeiou]{2,}")%>%unique()%>%length()
```

Find and display the word(s) with the most consecutive vowels (anywhere in the word).

-- `frseeeeeeeeeeeeeeeeeeeefrong` is the word with the most consecutive vowels.
```{r}

c_vowels <- words$word%>%
        str_extract_all("[aeiou]{2,}", 
                        simplify = TRUE)%>% 
        as_tibble() %>% 
        cbind(words$word)%>%
        mutate(l1 = nchar(V1))%>%
         mutate(l2 = nchar(V2))%>%
                 mutate(l3 = nchar(V3))%>%
                  mutate(l4 = nchar(V4))%>%
                 mutate(l5 = nchar(V5))%>%
                 mutate(l6 = nchar(V6))

# find the max number of consecutive vowels
map_dbl(c_vowels[,8:13], max)

c_vowels%>% filter(l1 == 20)%>%select(`words$word`)
```


c) English spelling
Empirically verify the rule “i before e except after c”. No need to become a linguist here; simply tabulate the proportion of words when the rule holds and when it does not.
```{r}

eng <- words$word%>%
        str_subset("(^ie)|[abd-z]ie|cei")%>%
        unique()

eng_n <- words$word%>%str_subset("(^ei)|[abd-z]ei|cie")%>%
        unique()

eng_spell <- matrix(c(length(eng), length(eng_n)), 1)
colnames(eng_spell) <- c( 'English spelling', "Not English spelling")
prop.table(eng_spell)*100


```

# 2. MTA Delays


## a) Reduce the data 

```{r}
rm(list = ls())
mta <- read_rds("mta.RDS")

data <-mta%>%filter(is_retweet == FALSE,
                    str_detect(text, "^@.*") == FALSE)%>%
        select(text, created_at)
```

## b) Time of Delay

Pattern: XX trains are running with delays because of xx problems.
```{r}
library(lubridate)
library(tidyverse)
timed <- data%>%
        filter(str_detect(text, "trains are running with delays") == TRUE)%>% 
        mutate(w_day = wday(created_at, label = T),
               clock = lubridate::hour(created_at))%>%mutate(period=
    case_when(
      between(clock, 6, 9) ~ "mornings",
       between(clock, 10, 14) ~ "mid-day",
       between(clock, 15, 17) ~ "afternoon",
      between(clock, 18, 21) ~ "evening",
      between(clock, 22, 24) ~ "night",
      between(clock, 0, 5) ~ "night"
    ))

```

Provide a table that shows delays by day of the week and time of day. Use the following time periods: mornings (6-10), mid-day (10-15), afternoon (15 - 18), evening (18- 22), and night (22 - 24; 0-6). What do you find?

### Delays by day of the week 
```{r}
timed%>%group_by(w_day)%>%summarise(n=n())

```

```{r, echo=FALSE}
timed%>%group_by(w_day)%>%summarise(n=n())%>%
        ggplot(aes(w_day, n, fill = 1/n))+
        geom_bar(stat="identity")+ 
        xlab('Day of the week')+
        ylab('Number of Delays')+
        theme_bw(base_family = 'Palatino')+
        theme(legend.position="none")

```

### Delays by and time of day

```{r}
timed$period <- factor(timed$period, ordered = TRUE, 
                    levels = c("mornings", 
                               "mid-day",
                               "afternoon", 
                               "evening",
                               "night"))

timed%>%group_by(period)%>%summarise(n=n())
```

```{r, echo=FALSE}
timed%>%group_by(period)%>%summarise(n=n())%>%
        ggplot(aes(period,n ,fill = 1/n))+
        geom_bar(stat="identity")+ 
        xlab('Time of day')+
        ylab('Number of Delays')+
        theme_bw(base_family = 'Palatino')+
        theme(legend.position="none")

```

## c) Type of Delay
Among the set of tweets in part b), try to categorize the types of delays. No need to be exhaustive but try to pick up the top 3-5 reasons for delays. 
```{r}
typed <- timed$text%>%
        str_split("because of", n= 2, simplify = TRUE)%>%
        .[,2]%>%word(1, 4)%>%
        as_tibble()%>%
        rename(reason = value)



typed%>%filter(is.na(reason) == F )%>%
        group_by(reason)%>%
        summarise(n = n())%>%
        top_n(20, n)%>% arrange(desc(n))
        
        
```

Combine them into reasonable categories if necessary (e.g. signal problems, medical, technical problems, etc.). Provide an overview (table or graph) of which types of delays are most common.

```{r}
typed%>%filter(is.na(reason) == F )%>%
        group_by(reason)%>%
        summarise(n = n())%>%
        top_n(6, n)%>% arrange(desc(n))%>%
        ggplot(aes(reason,n ,fill = 1/n))+
        geom_bar(stat="identity")+ 
        xlab('Reason')+
        ylab('Number of Delays')+
        theme_bw(base_family = 'Palatino')+
        theme(legend.position="none")

```

## d) Which train lines affected?

Write a regex pattern that captures which train lines are affected by delays. 
```{r}
lined <- timed%>%select(text, w_day)%>% mutate(train = str_extract(text, 
                                  "(.*)(?= train[s]* are)"))

lined <- lined%>% 
        mutate(train_s = str_remove_all(train,
                                        ".*bound[\\b\\s]"))%>%
        mutate(weekend = ifelse(w_day %in% c("Sun", "Sat"), 
                                "weekend", 
                                "weekday"))


lines <-lined%>% select(train_s, weekend)%>% 
        mutate(line = str_remove_all(train_s, "\\b[A-Za-z]{2,}\\b")%>%
        str_remove_all("[^A-Z0-9]")%>%
        str_replace_all('([A-Z0-9])\\1+', '\\1'))%>%
        select(-train_s)%>%
        mutate(i = row_number())

# max(map_dbl(lines$line, nchar))
# lines$i[nchar(lines$line) == 8]

line_n <- paste0("line", 1:8)

library(reshape2)

lines <- cbind(reshape2::colsplit(lines$line, "", names = line_n),
               lines[,3], lines[,1])

tidy <- lines %>% 
  reshape2::melt(variable.name = "note",
                 value.name = "train",
                 id.vars = c("i", 'weekend'))

```

Provide a summary of which train lines are affected by weekday vs. weekend.

```{r, fig.align='center', fig.height=10, fig.width= 15}
plot<-tidy%>%filter(train !="")%>%
        select(train,weekend)%>%
        group_by(train,weekend)%>%summarise(n = n())%>%
        mutate(weekend, percent = paste0(sprintf("%1.1f",
                                          n/sum(n)*100),"%"))

plot


ggplot(plot, aes(train, n, fill= weekend))+
        geom_bar(stat="identity") +
        geom_text(aes(label=percent, y=n-15), size = 3.8,
                  vjust=0.2)+
        ylab("number of delays")+ xlab("line")+
        ggtitle('Lines affected by Weekday vs. Weekend')+
        theme_bw(base_family = "Palatino", base_size = 13)+
        theme(plot.title = element_text(hjust = 0.5))
        

        
```